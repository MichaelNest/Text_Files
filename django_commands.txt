
				Установка CentOS на виртуальную машину:

1) Создаем Виртуальную Машину - Выброть место росположения ВиртМашины и вирт.диска, 1ГГб ОЗУ, 8ГГб - диск, 
	Сеть - Сетевой мост, Носители - выбрать загрузочный образ, Общ настройки - Дисплей - Автоматически, VBoxSVGA 
2) Выбрать язык - русский, часовой пояс и время, выбрать в розделе - росположение установки галочку 
	и автоматическую розбивку розделов, Прогр.обеспечение - Минимальная конфигурация+первые две галочки
3) Задать пароль в розделе root и по необходимости создать юзера, перезагрузить машину после установки
4) Ввести логин и пароль - войти в систему

5) Настройка сети:cd /etc/sysconfig/network-scripts/
6) vi ifcfg-enp0s3 - открываем этот файл редактором vi
7) Откроется содержимое файла настроек сети: меняем параметр на 'yes' : ONBOOT = 'yes', выходим из редактора
8) Пишем ifup ifcfg-enp0s3 находясь в дериктории network-scripts ip- таким образом мы поднимаем наш интерфейс вручную
9) Вводим комманду: ip addr - получаем информацию, в том числе там будет наш ip-address для нашего интерфейса enp0s3
10) Обновим пакеты (находясь в дериктории network-scripts): yum update - обновятся все пакеты на последние новые
					192.168.0.103/24

11) Устанавливаем доп утилиты для работы с разными репоз-ми (находясь в дериктории root (~)): yum install yum-utils
12) Устанавливаем дополнительные зависимости для python: yum-builddep python
13) Скачиваем архив с Питоном: curl -O https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz
14) Распаковываем архив: tar -xf Python-3.6.1.tgz
15) Переходим в папку Python-3.6.1 : cd Python-3.6.1
16) Применим три команды для зборки: ./configure ,Затем команда make ,Затем make install
17) Смотрим: python3 --version

18) Устанавливаем виртуальное окружение (мы в ~): pip3 install virtualenv
19) Cоздаем папку, где будут храниться виртуальные окружения для наших проектов: mkdir environments
20) Переходим в нее: cd environments
21) Cоздаем виртуальное окружение для нашего текущего виртуального проекта: virtualenv my_env
22) ls my_env ,, cd my_env ,, Входим в локализацию нашего виртуального проекта: source bin/activate
			      Выход из локализации виртуального проекта:        deactivate

23) (my_env) Мы находимся в нашем виртуальном окружении, теперь установим Django в контексте нашего вирт окружения: 
										pip3 install django==2.1.*
pip3 freeze - посмотреть версию джанго
24) Создадим проект django в папке с нашим виртуальным окружением: 
						django-admin startproject mysite ,, cd mysite ,, ls -la
25) Запуск сервера: ./manage.py runserver xxx.xxx.xxx.xxx:8000 - надо будет указать наш ip-adress.
	Это если мы на виртуальной машине. Если мы на локальной - то ip-adress можно не указывать, а перейти потом
	по адресу, который будет выдан в конце выполнения команды ./manage.py runserver
26) Чтоб открыть порт 8000 в CentOS надо набрать следующую команду:
	firewall-cmd --zone=public --add-port=8000/tcp --permanent && firewall-cmd --reload

27) Запустить сервер п.25, и перейти в браузере по ссылке, которая должна будет появиться в консоли.
27) Устранение ошибки Django: надо добавить наш ip в массив allowed host в файле settings.py:
		ls ,, cd mysite ,, vi settings.py ,, ALLOWED HOST = ['XXX.XXX.XXX.XXX']
28) п.25 - запускаем сервер root/Python-3.6.1/enveronment/my_env/mysite_1

-------------------------------------------------------------------------------------------------------------------
29) Установка утилиты tree: yum update && yum install tree
30) db.sqlite3 --> файл базы данных sqlite
    manage.py --> файл-скрипт для взаимодействия (например запуска) нашего проекта
    mysite_1 --> папка с питон-проектом
    __init__.py --> файл указывающий что это - питон-проект
    __pycache__ --> папка с кеш-файлами
    settings.py --> файл с конфигурацией и настройками проекта. Мы туда добавляли ip-adress в список ALLOWED_HOST
    urls.py --> файл с конфигурацией урлов в проекте
    wsgi.py --> точка входа нашего проектв для совместных wsgi-серверов
31) (my_env) [root@localhost mysite]# ./manage.py runserver --> самый простой способ запустить наш сервер
32) (my_env) [root@localhost mysite]# ./manage.py runserver 8080 --> если мы хотим поменять порт на 8080
33) (my_env) [root@localhost mysite]# ./manage.py runserver 0.0.0.0:8080 или 0:8000 или 192.168.0.108:8000 --> 
    --> если я хочу чтоб был доступ из локальной сети (показать на других компьютерах локальной сети)
-------------------------------------------------------------------------------------------------------------------
34) (my_env) [root@localhost mysite]# ./manage.py startapp polls или 
python3 manage.py startapp name--> создаем папку polls
35) cd polls && tree-->перейдем и посмотрим на содержимое папки polls - это все части нашего нового приложения polls
36) views.py --> открываем этот файл и пишем в нем програму нашего приложения:
	from django.shortcuts import render
	from django.http import HttpResponse

	def index(request):
		return HttpResponse("Hello - People!!") --> это самое простое представление в django
37) Создаем файл urls.py в проекте polls, где привяжем урл к вьюшке. открывоем его и пишем:
	from django.conf.urls import url
	from . import views --> импортируем файл views из текущей директории

	urlpatterns = [url(r'^$', views.index, name = 'index')]
38) Пропишем теперь в файле urls.py папки mysite_1:
	from django.urls import include, path
	# from django.conf.urls import include, url --> добавляем для импорта метод include
	from django.contrib import admin

	urlpatterns =[path('admin/', admin.site.urls),
		      path('polls/', include('polls.urls'),
		      # url(r'^admin/', admin.site.urls), 
		      # url(r'^polls/', include('polls.urls')) --> добавляем эту строчку
39) Набираем в браузере адеес: 192.168.0.108:8000/polls/ - высветится наша надпись!!
--------------------------------------------------------------------------------------------------------------------
40) - создать временную папку на нашем реальном компьютере
    - нужно монтировать удаленный католок с нашим проектом через SSH (mkdir tmp/mysite && ls tmp/mysite)
    - установить  sshfs - sudo apt install sshfs
    - sshfs root@192.168.000.103:/root/Python-3.6.1/environments/my_env/my_first_site /tmp/mysite/
# 41) Выйти из виртуального окружения (deactivate) и перейти в дерикторию root
# 42) sshfs - клиент для работы с файловой системой через ssh - позволяет монтировоть удаленную систему в нашу систему,
	так как будто она является локальной дерикторией
# 43) Cоздаем папку для нашего проекта tmp/mysite
# 44) sshfs root@192.168.0.108:/root/Python-3.6.1/environments/my_env/mysite_1 /tmp/mysite_1
	(это абс путь на основной машине)
# 45) Для Винды: установитьт две утилиты: winfsp-1.4.19016 и sshfs-win-2.7.17334-x64 
	из http://www.secfs.net/winfsp/download/                                        Не работает
# 46) Войти: Проводник - Этот компьютер - правой кн мыши - Подключить сетевой диск - 
	- \\sshfs\root@192.168.0.108:\root\Python-3.6.1\environments\my_env\mysite_1	Не работает
----------------------------------------------------------------------------------------
47) Как писать свои команды в alias:
	--- Войти через Вим в файл:~$ vim .bashrc --> 
	--- Дописать строку: alias mysite='mkdir /tmp/mysite && sshfs root@192.168.000.103:/root/Python-3.6.1/environments/my_env/my_first_site /tmp/mysite/' 

root@192.168.000.103:/root/environmentsm/my_env_m/appm/blogengine

	Сохранимся и надо перезапустить систему. allias - для создания своих комманд
48) PuTTY - утилита для ftp-соединения windows-linux. Работа с файлами сервера в эмуляторе терминала.
		вбивать ip-адрес сервера и порт 22 или 8000
49) Filezilla - самый оптимальный FTP-клиент, позволяет в визуальном режиме манипулировать файлами с сервера
--------------------------------------------------------------------------------------------------------------------
50) Механизм действия Django, когда кто то заходит на сайт:
	- обращение к главному конфигурационному ресурсу с урлами в файлу settings.py
	- ROOT_URLCONF = 'mysite_1.urls' - Django видит - где находится файл с урлами - в папке mysite в файле urls
	- в файле urls.py находит переменную urlpatterns - это список, состоящий из функции url
	- затем django сопоставляет url-adress запроса с каждым регулярным выражением 
	  типа в path('polls/', include('polls.urls')) с регулярным выражением 'admin/' 
	- если находит совпадение - то останавливается и вызывает указанное представление - include('polls.urls')
	- представление include('polls.urls') - это функция python в которую передается обьект http.request
51) Функция url ( у меня  path):
	- path('polls/', include('polls.urls')) - имеет четыре параметра - два обязательных и два необязательных
	- 1-регулярное выражение 'polls/', 2-функция представления include('polls.urls'), 3-keywords, 4-name

52) Cоздаем файл views.py или копируем его из polls в mysite_1 и изменяем
53) Импортируем его в файл urls.py --> from . import views
54) Создаем в файле urls.py новое правило --> path('test/', views.test)
55) Переходим в views.py и меняем у функции index имя и выводимый текст:
	def test(request):
		return HttpResponse('TEST')
56) Набираем в браузере 192.168.0.108:8000/test/ - должно выдать страничку со словом TEST
57) Добавим в urls новую функцию: path('test/2020/', view.test_2020) и в view добавим новую функцию-представление:
	def test_2020(request):
		return HttpResponse('TEST_2020')

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
			Django (lessons Molchanov)

1) Файлы в app (blog):
	--- urls.py - отвечает за маршрутизацию запроса пользователя, который прилетает к нам из браузера
	--- views.py - отвечает за обработку этого запроса
	--- models.py - отвечает за хранение данных
2) ./manage.py runserver 5000 --- запуск сервера на 5000-м порту
3) Миграции:
	--- ./manage.py migrate - производятся миграции и 			попутно создается база SQLite
4) редактируем файл urls.py в папке blogengine:
	
5) Model-View-Controller:
	--- Model - хранение базы данных - отвечают файлы 				models.py
	--- View - отдельно пишем код для представления 		пользователю - отвечают HTML-шаблоны
	--- Controller - для обработки запроса пользователя 			- отвечают файлы views.py
6) Файл urls.py в blogengine:
	from django.contrib import admin
	from django.urls import path
	from .views import hello

	urlpatterns = [
    		path('admin/', admin.site.urls),
    		path('blog/', hello)]
7) Чтоб использовать заданный метод hello при вызове .../blog/ - надо создать файл views.py где создать метод hello
	from django.http import HttpResponse
	def hello(request):
    	    return HttpResponse('<h1>Hello World-Blog!!!</h1>')
8) Подключаем наше второе приложение blog:
	--- в blogengine открываем файл settings.py
	--- в переменной INSTALLED_APPS дописываем в список 'blog'
	---- редактируем файл urls.py в blogengine:
	 аргументы path --- 2 позиционных - 'blog' - шаблон урла и метод, который должен выполняться при вызове этого шаблона. Еще 2 - это имя path и доп.данные в виде словаря, которые можно или нужно передать в метод.
	---- импортируем метод include: from django.urls import include
	---- переадресовываем через include на файд urls который в приложении blog --- path('blog/', include('blog.urls'))
 	---- создаем файл urls.py в blog - пишем в нем следующее: 
from django.urls import path
from .views import *

urlpatterns = [
    path('', post_list)
]
	---- переходим в файл views.py который в blog и создаем там метод post_list:
from django.shortcuts import render
from django.http import HttpResponse

def post_list(request):
    return HttpResponse('<h1>Hello WORLD~!!!</h1>')
----------------------------------------------------------------------------------------------------

9) Создаем в приложении blog папку templates, а в ней еще одну папку blog - для шаблонов html
10) Создадим файл index.html
11) Прописываем его на исполнение в view.py приложения blog:
def post_list(request):
    # return HttpResponse('<h1>Hello WORLD~!!!</h1>')
    return render(request, 'blog/index.html')

Все htmi-шаблоны django будет искать в папке templates
12) Вводим в файле view.py переменную n = 'Misha', прописываем в render свойства context={'name':n}, а в index.html-например в параметре 
		<p>{{name}}</p>
 прописываем имя переменной из context --- визуально отобразится misha
13) Если переменная - список и надо вывести каждый его элемент отделно - в шаблоне применяется цикл:
    {% for name in names %}
        <p>
            {{name}}
        </p>
    {% endfor%}
14) Базовый шаблон-родитель:
15) Копируем ссылку с сайта Bootstrap:
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous"> ---- вставляем его в Базовый шаблон
16) Добавляем в Базовый шаблон общие для всех шаблонов компоненты: 
	---- на сайте Bootstrap --- Components --- Navbar --- Выбираем какое нибудь меню --- копируем код --- вставляем его в Базовый шаблон в <body>
17) в <title> размечаем общие блоки:
	{% block title %}
	    blog Engine
	{% endblock %}
18) В <body> после css-шаблона розмещаем блоки с контентом
	{% block content %}
	    There is no any content!!
	{% endblock %}

19) Переходим на страницу index.html и убираем там все общие елементы --- прописываем что частный шаблон росширяет общий:
	{% extands 'blog/base_blog.html' %}
и продублировать блоки:
{% extends 'blog/base_blog.html' %}

{% block title %}
    blog Engine
{% endblock %}

{% block content %}
    {% for name in names %}
        <p>
            {{name}}
        </p>
    {% endfor%}
{% endblock %}

20) Создаем папку templates на общем уровне - тут будут содержаться шаблоны для всего сайта --- создаем внутри этой папки файл base.html
21) Переносим в файл base содержимое из base_block - а base_block станет росширять блок base: {% extends 'base.html' %}

22) Подключаем base.html прописывая его в blogengine/settings.py --- TAMPLATES --- ключ DIRS --- os.path.join(BASE_DIR, 'tamplates')
где 'tamplates'- название папки, а BASE_DIR - абсолитный путь
куда подставляется имя файла 'tamplates'

------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
			Работа с базами данных:

1)Создаем модель нашей базы данных, например у нас она будет называться - post
Для этого в нашем приложении blog в файле models.py создаем класс Post:
class Post(models.Model):
    title = models.CharField(max_length=150, db_index= True)
    slug = models.SlugField(max_length=150, unique=True)
    body = models.TextField(blank=True, db_index=True)
    date_pub = models.DateTimeField(auto_now_add=True)

SlugField почти такой же класс, как и CharField, только он дозволяет использовать буквы обоих регистров, цифры, подчеркивания и дефисы. Остальное использовать нельзя.       --- unique=True - требование уникальности
--- db_index - флаг на индексацию, чтоб можно было лучше искать
--- blank=True - флаг о том, что можно оставлять поле пустым
--- auto_now_add=True - флаг о том, что поле будет заполняться автоматически при сохранении обьекта в базе данных
--- def __str__(self):
	return '{}'.format(self.title) --- переопределяем метод, отвечающий за вывод информации об обьекте - будет выдаваться title

2) Теперь надо занести данные файла models.py в базу данных через механизм мигрфции:
	---- ./manage.py makemigrations - в директории blog появится папка с миграциями и там будет файл с нашими данными бд

3) Применяем миграции: ---- ./manage.py migrate

4) Переход в консоль Джанги:
	---- ./manage.py shell
----------------------------------------------------------------
5) Эксперимент в консоли:
>>> from blog.models import Post
>>>
>>> p = Post(title='New Post', slug='new-slug', body='new post body')
>>> p --- выведится имя title, которое мы переопределили в def __str__(self)
		LoockUpstoo
>>> p.title ---
>>> p.save() ---после этой команды сохранения будет задано id
>>> p.id --- выведется id
>>> dir(p) --- чтоб посмотреть все методы обьекта p
При создании обьекта Джанго присваевает ему менеджера обьекта.
Он находится в атрибуте Objects - через него можно влиять на обьект.
>>> p1 = Post.objects.create(title='new post 2', slug='new-post2', body='body2') --- создание обьекта через objects
>>> Post.objects.all() --- посмотреть все созданные обьекты 
>>> post = Post.objects.get(slug='new-slug') --- метод get возвращает нам обьект у которого есть указанный нами идинтификационный параметр - в данном случае - slug='new-slug' - значит обьекту post будет присвоен обиект p.
	Метод get чувствителен к регистру данныхя, которые мы подаем в скобках.
>>> post = Post.objects.get(slug__iexact='New-slug') --- __iexact --- позволяет нам делать регистронезависимый запрос (i --- значит независимость от регистра, а exact - значит что требуется полное совпадение)
>>> post = Post.objects.filter(slug__contains='new') --- __contains --- значит что нам нужно вернуть все обьекты, у которых усть slug содержащий 'new', а так как их несколько - то надо использовать вместо get -- filter
--------------------------------------------------------------------------
6) Пишем во blog/view.py:
	--- импортируем класс Post
	--- создаем обьект Post
7)  В файле templates/blog/index.html - прописываем обьект post:
{% extends 'blog/base_blog.html' %}

{% block title %}
    Post List
{% endblock %}

{% block content %}
    <h1 class='mb-5'>Posts:</h1>
    {% for post in posts %}
        <p>
            {{post.title}}
        </p>
    {% endfor%}
{% endblock %}
обавляем еще макетов с Boostrat и верстаем дальше

7) Заходим в шаблон templates/base.html и редактируем там
8) В blog/url.py задаем параметр name='post_list_url'



-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
###############################################################################################
###############################################################################################
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------

				Django-Girls:
0) Есть ряд шагов по установеу Python и Виртуального Окружения - их следует смотреть в начале этого файла:
	--- Cоздаем папку, где будут храниться виртуальные 		окружения для наших проектов: mkdir environments
	--- Переходим в нее: cd environments
	--- sudo apt-get install python3-venv
	--- ??? Cоздаем виртуальное окружение для нашего текущего виртуального проекта: virtualenv my_env
	
1)$ python3 -m venv myvenv - создаем виртуальное окружение в какой небудь специально созданной папки для виртуальных окружений.
2) Заходим в папку myvenv и набираем команду:
		--- source bin/activate
   Для выхода из виртуального окружения заходим в myvenv и набираем:       --- deactivate
3) (myvenv) ~$ python3 -m pip install --upgrade pip --- проверяем и устанавливаем pip
4) pip install django==2.1.* --- устанавливаем Джанго (Django~=2.2.4)
   pip freeze - посмотреть версию джанго
5) django-admin startproject mysite . --- создаем наш сайт
6) Настройки в setting.py:
	--- TIME_ZONE = 'Europe/Moscow' --- часовой пояс
	--- LANGUAGE_CODE = 'ru-ru'--- язык-страна
	--- STATIC_ROOT = os.path.join(BASE_DIR, 'static') --- добавить в самом низу файла эту переменную --- информацию о расположении статических файлов (CSS и другое)
	--- ALLOWED_HOSTS = ['192.168.000.103','127.0.0.1', '.pythonanywhere.com'] - добавить наш ip-address нашего сервера

6.1) python manage.py migrate --- создадим файл нашей базы данных
6.2) python manage.py runserver 192.168.000.103:8000 --- запуск нашего сервера
--------------------------------------------------------------
7) Создаем приложение в нашем проекте (находясь в директории, где находится файл manage.py):
	(myvenv) ~/djangogirls$ python manage.py startapp blog
8) Прописываем наше новосозданное приложение в файле settings.py основного (самого первого) приложения:
	--- INSTALLED_APPS = [....., 'blog_app_1]
9) В файле blog_app_1/models.py - определяем все модели для нашего блога:
	(https://docs.djangoproject.com/en/1.11/ref/models/fields/#field-types). --- тут все о полях моделей и обьектах
10) Добавление нашей модели в базу данных:
	--- (myvenv) ~/djangogirls$ python manage.py makemigrations blog_app_1
11) Посмотреть статус миграции:
	--- (myvenv) ~/djangogirls$ python manage.py migrate blog_app_1
-------------------------------------------------------------
12) Давай откроем файл --- blog/admin.py --- и заменим его содержимое на (смотри файл)
--- Мы импортировали (включили) модель Post, которую определили в предыдущей главе. Чтобы наша модель стала доступна на странице администрирования, нам нужно зарегистрировать её при помощи строки --- admin.site.register(Post).
13) Запустить сервер и зайти в браузере по адресу:  		--- http://127.0.0.1:8000/admin/. 
14) Создаем суперпользователя для доступу в админку:
	--- (myvenv) ~/djangogirls$ python manage.py createsuperuser --- задаем логин, ящик и пароль (admin, admin)
15)Если ты хочешь узнать больше об администрировании Django, то ознакомься с этим разделом официальной документации: 
	--- https://docs.djangoproject.com/en/1.11/ref/contrib/admin/.
---------------------------------------------------------------
16) Создаем git-репозиторий в папке проекта:
	--- /home/ubuntu/PyProjects/Environments/dg_venv/my_dg_site

17) $ git init
	$ git config --global user.name "Your Name"
	$ git config --global user.email you@example.com
18) Создаем в дериктории проекта my_dg_site файл .gitignore и делаем в нем запись:
	*.pyc
	*~
	__pycache__
	myvenv
	db.sqlite3
	/static
	.DS_Store
19) Создаем репозиторий на GitHub стандартным образом
20) Регистрируемся на сервере - PythonAnywhere
21) Создать  API-token для PythonAntwhere:
	--- Account - API-token - Create new API-token --- токен сгенерирован и пусть там и находится пока что
22) Открываем терминал bash в главном окне и загружаем через pip помошник - для дальнейшей работы с загрузкой нашего сайта
	--- pip3.6 install --user pythonanywhere
23) Загружаем с GitHab нашу директорию:
	--- pa_autoconfigure_django.py https://github.com/MichaelNest/My_First_Django_site.git
24) Создаем на сервере суперюзера:
	--- python manage.py createsuperuser
	
25) https://docs.djangoproject.com/en/2.0/howto/deployment/checklist/ --- чек-лист по настройкам безопасности сайта
----------------------------------------------------------------
----------------------------------------------------------------
26) Начинаем прописывать urls:
	--- открываем файл buildblog/urls.py и прописываем там:
	from django.contrib import admin
	from django.urls import path, include --- это

	urlpatterns = [
    		path('admin/', admin.site.urls),
    		path('', include('blog.urls')), --- и это
		]

27) Созаем новый файл urls.py в директории blog --- blog/urls.py
		создадим там следующие записи:
		from django.urls import path
		from . import views

		urlpatterns = [path('', views.post_list, 			name='post_list')]
больше об URLconfs: https://docs.djangoproject.com/en/2.0/topics/http/urls/
------------------------------------------------------------------

28) Прописываем представление - файл blog/view.py:
	from django.shortcuts import render

	def post_list(request):
    		return render(request, 'blog/post_list.html', {})

Подробнее о представлениях в Django можно узнать из официальной документации: https://docs.djangoproject.com/en/1.11/topics/http/views/
------------------------------------------------------------------

29) Создаем в blog папку templates, а в ней папку blog - здесь будут храниться шаблоны html.
30) Создаем в blog/templates/blog - файд post_list.html, пишем в ней код шаблона:
		<html>
    			<p>Hi there!</p>
    			<p>It works!</p>
		</html>
31) Теги:
	<p> — это тег для параграфов; 
	</p>, соответственно, закрывает каждый параграф.
	<head></head> — это элемент, содержащий информацию о документе, которая не отображается на экране.
	<body></body> — это элемент, который содержит всё, что будет отражено на веб-странице.

Мы используем тег <head>, чтобы сообщить браузеру о настройках страницы, и тег <body> — о её содержимом.

	<h1>Заголовок</h1> — главный заголовок страницы;
	<h2>Подзаголовок</h2> — для заголовков второго уровня;
	<h3>Заголовок третьего уровня</h3> … и так далее, вплоть до <h6>;
	<p>A paragraph of text</p>
	<em>текст</em> подчёркивает твой текст;
	<strong>текст</strong> — жирный шрифт;
	<br /> — переход на следующую строку (внутрь br тега нельзя ничего поместить);
	<a href="https://djangogirls.org"> link </a> создаёт ссылку;
	<ul><li>первый элемент</li><li>второй элемент</li></ul> создаёт список, такой же как этот!
	<div></div> определяет раздел страницы.

-------------------------------------------------------------------
32) Коммитим в Git:
	--- git status
	--- git add --all .
	--- git status
	--- git commit -m 'Changed the HTML for the site.'
	--- git push
33) Загружаем новый код на PythonAnywhere и перезапускаем приложение:
	Открываем вкладку "Consoles" на PythonAnywhere и переключись на уже запущенную консоль Bash (или новую). Затем набери следующую команду:
	--- $ cd ~/<your-pythonanywhere-domain>.pythonanywhere.com
	--- $ git pull --- сайт зальется на сервер
	Наконец, переключись на вкладку "Web" и нажми кнопку "Reload".
-------------------------------------------------------------------
-------------------------------------------------------------------
34) QuerySet — список объектов заданной модели. QuerySet позволяет читать данные из базы данных, фильтровать и изменять их порядок.

Заходим в интерактивную консоль Django:
	--- (myvenv) ~/djangogirls$ python manage.py shell
35) Набираем следующие команды и смотрим - какие посты у нас есть:
	--- from blog.models import Post
	--- Post.objects.all()
36) Создать объект Post в базе данных:
	--- from django.contrib.auth.models import User
	--- User.objects.all() --- посмотреть какие пользователи у нас есть
	--- me = User.objects.get(username='admin') --- создаем экземпляр обьекта пользователя
	--- Post.objects.create(author=me, title='Sample title', text='Test') --- создаем новый пост
	--- Post.objects.all() --- посмотрим пост, что мы создали

37) Фильтрация обьектов:
	--- Post.objects.filter(author=me) --- фильтрация по пользователю
	--- Post.objects.filter(title__contains='title') --- фильтрация по слову в титле
	--- from django.utils import timezone
	--- Post.objects.filter(published_date__lte=timezone.now())
--- фильтрация опубликованных постов по дате публикации
	--- post = Post.objects.get(title="Sample title")
	--- post.publish() --- выбрать и опубликовать пост
	--- Post.objects.order_by('created_date') --- сортировка по дате создания
	--- Post.objects.order_by('-created_date') --- сортировка по дате создания но в обратной последовательности
--- Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date') ---- QuerySets можно сцеплять, создавая цепочки.
	--- exit() --- выход из консольного ввода shell
--------------------------------------------------------------------

38) Динамически изменяющиеся данные в шаблонах:
Передаем QuerySet posts в шаблон:
	--- from django.shortcuts import render
	--- from django.utils import timezone
	--- from .models import Post

	--- def post_list(request):
    		--- posts = 			Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
    		--- return render(request, 'blog/post_list.html', {'posts': posts})

Подробнее о QuerySets в Django можно узнать в официальной документации: https://docs.djangoproject.com/en/1.11/ref/models/querysets/
-------------------------------------------------------------------
39) Чтобы вставить переменную в шаблон Django, нам нужно использовать двойные фигурные скобки с именем переменной внутри:

	--- blog/templates/blog/post_list.html
	--- {{ posts }}
40) 	{% for post in posts %}
    		{{ post }}
	{% endfor %} --- передача данных в шаблон с помощью цикла

	--- |linebreaksbr --- прогоняет текст через фильтр для преобразования переносов строк в параграфы.
--------------------------------------------------------------------
41) Bootstrap: Вставим эти строки в <head></head>:
	<head>
        	<title>My Great Blog</title>
        	<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
        	<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    	</head>

42) Создаем папку static для хранения статических шаблонов CSS нашего проекта:
djangogirls
├── blog
│   ├── migrations
│   ├── static
│   └── templates
└── mysite

43) Создадим папку для CSS шаблонов и файл .css:
djangogirls
└─── blog
     └─── static
          └─── css
               └─── blog.css

---Найти коды цветов, например, здесь: http://www.colorpicker.com/.

44) h1 a {
    color: #FCA205;
}

h1 a — это CSS-селектор. Это означает, что мы применяем наши стили к каждому элементу a внутри элемента h1 (например, когда у нас в коде что-то вроде: <h1><a href="">link</a></h1>).

Class и id – это имена, которые ты сама присваиваешь элементам. Классы (сlass) определяют группы элементов, а идентификаторы (id) указывают на конкретные элементы

45) Затем нам также нужно сообщить нашему HTML-шаблону о том, что мы добавили CSS. Открой файл blog/templates/blog/post_list.html и добавь эту строку в самое начало:

		{% load static %}

Мы просто загружаем здесь статические файлы :) Далее между <head> и </head>, после ссылок на файлы Bootstrap CSS, добавь такую строку:

	<link rel="stylesheet" href="{% static 'css/blog.css' %}">

Смотри содержимое файлов: 
	--- post_list.html
	--- blog.css
-------------------------------------------------------------------
46) 










