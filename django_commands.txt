
				Установка CentOS на виртуальную машину:

1) Создаем Виртуальную Машину - Выброть место росположения ВиртМашины и вирт.диска, 1ГГб ОЗУ, 8ГГб - диск, 
	Сеть - Сетевой мост, Носители - выбрать загрузочный образ, Общ настройки - Дисплей - Автоматически, VBoxSVGA 
2) Выбрать язык - русский, часовой пояс и время, выбрать в розделе - росположение установки галочку 
	и автоматическую розбивку розделов, Прогр.обеспечение - Минимальная конфигурация+первые две галочки
3) Задать пароль в розделе root и по необходимости создать юзера, перезагрузить машину после установки
4) Ввести логин и пароль - войти в систему

5) Настройка сети:cd /etc/sysconfig/network-scripts/
6) vi ifcfg-enp0s3 - открываем этот файл редактором vi
7) Откроется содержимое файла настроек сети: меняем параметр на 'yes' : ONBOOT = 'yes', выходим из редактора
8) Пишем ifup ifcfg-enp0s3 находясь в дериктории network-scripts ip- таким образом мы поднимаем наш интерфейс вручную
9) Вводим комманду: ip addr - получаем информацию, в том числе там будет наш ip-address для нашего интерфейса enp0s3
10) Обновим пакеты (находясь в дериктории network-scripts): yum update - обновятся все пакеты на последние новые
					192.168.0.103/24

11) Устанавливаем доп утилиты для работы с разными репоз-ми (находясь в дериктории root (~)): yum install yum-utils
12) Устанавливаем дополнительные зависимости для python: yum-builddep python
13) Скачиваем архив с Питоном: curl -O https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz
14) Распаковываем архив: tar -xf Python-3.6.1.tgz
15) Переходим в папку Python-3.6.1 : cd Python-3.6.1
16) Применим три команды для зборки: ./configure ,Затем команда make ,Затем make install
17) Смотрим: python3 --version

18) Устанавливаем виртуальное окружение (мы в ~): pip3 install virtualenv
19) Cоздаем папку, где будут храниться виртуальные окружения для наших проектов: mkdir environments
20) Переходим в нее: cd environments
21) Cоздаем виртуальное окружение для нашего текущего виртуального проекта: virtualenv my_env
22) ls my_env ,, cd my_env ,, Входим в локализацию нашего виртуального проекта: source bin/activate
			      Выход из локализации виртуального проекта:        deactivate

23) (my_env) Мы находимся в нашем виртуальном окружении, теперь установим Django в контексте нашего вирт окружения: 
										pip3 install django==2.1.*
pip3 freeze - посмотреть версию джанго
24) Создадим проект django в папке с нашим виртуальным окружением: 
						django-admin startproject mysite ,, cd mysite ,, ls -la
25) Запуск сервера: ./manage.py runserver xxx.xxx.xxx.xxx:8000 - надо будет указать наш ip-adress.
	Это если мы на виртуальной машине. Если мы на локальной - то ip-adress можно не указывать, а перейти потом
	по адресу, который будет выдан в конце выполнения команды ./manage.py runserver
26) Чтоб открыть порт 8000 в CentOS надо набрать следующую команду:
	firewall-cmd --zone=public --add-port=8000/tcp --permanent && firewall-cmd --reload

27) Запустить сервер п.25, и перейти в браузере по ссылке, которая должна будет появиться в консоли.
27) Устранение ошибки Django: надо добавить наш ip в массив allowed host в файле settings.py:
		ls ,, cd mysite ,, vi settings.py ,, ALLOWED HOST = ['XXX.XXX.XXX.XXX']
28) п.25 - запускаем сервер root/Python-3.6.1/enveronment/my_env/mysite_1

-------------------------------------------------------------------------------------------------------------------
29) Установка утилиты tree: yum update && yum install tree
30) db.sqlite3 --> файл базы данных sqlite
    manage.py --> файл-скрипт для взаимодействия (например запуска) нашего проекта
    mysite_1 --> папка с питон-проектом
    __init__.py --> файл указывающий что это - питон-проект
    __pycache__ --> папка с кеш-файлами
    settings.py --> файл с конфигурацией и настройками проекта. Мы туда добавляли ip-adress в список ALLOWED_HOST
    urls.py --> файл с конфигурацией урлов в проекте
    wsgi.py --> точка входа нашего проектв для совместных wsgi-серверов
31) (my_env) [root@localhost mysite]# ./manage.py runserver --> самый простой способ запустить наш сервер
32) (my_env) [root@localhost mysite]# ./manage.py runserver 8080 --> если мы хотим поменять порт на 8080
33) (my_env) [root@localhost mysite]# ./manage.py runserver 0.0.0.0:8080 или 0:8000 или 192.168.0.108:8000 --> 
    --> если я хочу чтоб был доступ из локальной сети (показать на других компьютерах локальной сети)
-------------------------------------------------------------------------------------------------------------------
34) (my_env) [root@localhost mysite]# ./manage.py startapp polls или 
python3 manage.py startapp name--> создаем папку polls
35) cd polls && tree-->перейдем и посмотрим на содержимое папки polls - это все части нашего нового приложения polls
36) views.py --> открываем этот файл и пишем в нем програму нашего приложения:
	from django.shortcuts import render
	from django.http import HttpResponse

	def index(request):
		return HttpResponse("Hello - People!!") --> это самое простое представление в django
37) Создаем файл urls.py в проекте polls, где привяжем урл к вьюшке. открывоем его и пишем:
	from django.conf.urls import url
	from . import views --> импортируем файл views из текущей директории

	urlpatterns = [url(r'^$', views.index, name = 'index')]
38) Пропишем теперь в файле urls.py папки mysite_1:
	from django.urls import include, path
	# from django.conf.urls import include, url --> добавляем для импорта метод include
	from django.contrib import admin

	urlpatterns =[path('admin/', admin.site.urls),
		      path('polls/', include('polls.urls'),
		      # url(r'^admin/', admin.site.urls), 
		      # url(r'^polls/', include('polls.urls')) --> добавляем эту строчку
39) Набираем в браузере адеес: 192.168.0.108:8000/polls/ - высветится наша надпись!!
--------------------------------------------------------------------------------------------------------------------
40) - создать временную папку на нашем реальном компьютере
    - нужно монтировать удаленный католок с нашим проектом через SSH (mkdir tmp/mysite && ls tmp/mysite)
    - установить  sshfs - sudo apt install sshfs
    - sshfs root@192.168.000.103:/root/Python-3.6.1/environments/my_env/my_first_site /tmp/mysite/
# 41) Выйти из виртуального окружения (deactivate) и перейти в дерикторию root
# 42) sshfs - клиент для работы с файловой системой через ssh - позволяет монтировоть удаленную систему в нашу систему,
	так как будто она является локальной дерикторией
# 43) Cоздаем папку для нашего проекта tmp/mysite
# 44) sshfs root@192.168.0.108:/root/Python-3.6.1/environments/my_env/mysite_1 /tmp/mysite_1
	(это абс путь на основной машине)
# 45) Для Винды: установитьт две утилиты: winfsp-1.4.19016 и sshfs-win-2.7.17334-x64 
	из http://www.secfs.net/winfsp/download/                                        Не работает
# 46) Войти: Проводник - Этот компьютер - правой кн мыши - Подключить сетевой диск - 
	- \\sshfs\root@192.168.0.108:\root\Python-3.6.1\environments\my_env\mysite_1	Не работает
----------------------------------------------------------------------------------------
47) Как писать свои команды в alias:
	--- Войти через Вим в файл:~$ vim .bashrc --> 
	--- Дописать строку: alias mysite='mkdir /tmp/mysite && sshfs root@192.168.000.103:/root/Python-3.6.1/environments/my_env/my_first_site /tmp/mysite/' 
	Сохранимся и надо перезапустить систему. allias - для создания своих комманд
48) PuTTY - утилита для ftp-соединения windows-linux. Работа с файлами сервера в эмуляторе терминала.
		вбивать ip-адрес сервера и порт 22 или 8000
49) Filezilla - самый оптимальный FTP-клиент, позволяет в визуальном режиме манипулировать файлами с сервера
--------------------------------------------------------------------------------------------------------------------
50) Механизм действия Django, когда кто то заходит на сайт:
	- обращение к главному конфигурационному ресурсу с урлами в файлу settings.py
	- ROOT_URLCONF = 'mysite_1.urls' - Django видит - где находится файл с урлами - в папке mysite в файле urls
	- в файле urls.py находит переменную urlpatterns - это список, состоящий из функции url
	- затем django сопоставляет url-adress запроса с каждым регулярным выражением 
	  типа в path('polls/', include('polls.urls')) с регулярным выражением 'admin/' 
	- если находит совпадение - то останавливается и вызывает указанное представление - include('polls.urls')
	- представление include('polls.urls') - это функция python в которую передается обьект http.request
51) Функция url ( у меня  path):
	- path('polls/', include('polls.urls')) - имеет четыре параметра - два обязательных и два необязательных
	- 1-регулярное выражение 'polls/', 2-функция представления include('polls.urls'), 3-keywords, 4-name

52) Cоздаем файл views.py или копируем его из polls в mysite_1 и изменяем
53) Импортируем его в файл urls.py --> from . import views
54) Создаем в файле urls.py новое правило --> path('test/', views.test)
55) Переходим в views.py и меняем у функции index имя и выводимый текст:
	def test(request):
		return HttpResponse('TEST')
56) Набираем в браузере 192.168.0.108:8000/test/ - должно выдать страничку со словом TEST
57) Добавим в urls новую функцию: path('test/2020/', view.test_2020) и в view добавим новую функцию-представление:
	def test_2020(request):
		return HttpResponse('TEST_2020')

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
			Django (lessons Molchanov)

1) Файлы в app (blog):
	--- urls.py - отвечает за маршрутизацию запроса пользователя, который прилетает к нам из браузера
	--- views.py - отвечает за обработку этого запроса
	--- models.py - отвечает за хранение данных
2) ./manage.py runserver 5000 --- запуск сервера на 5000-м порту
3) Миграции:
	--- ./manage.py migrate - производятся миграции и 			попутно создается база SQLite
4) редактируем файл urls.py в папке blogengine:
	
5) Model-View-Controller:
	--- Model - хранение базы данных - отвечают файлы 				models.py
	--- View - отдельно пишем код для представления 		пользователю - отвечают HTML-шаблоны
	--- Controller - для обработки запроса пользователя 			- отвечают файлы views.py
6) Файл urls.py в blogengine:
	from django.contrib import admin
	from django.urls import path
	from .views import hello

	urlpatterns = [
    		path('admin/', admin.site.urls),
    		path('blog/', hello)]
7) Чтоб использовать заданный метод hello при вызове .../blog/ - надо создать файл views.py где создать метод hello
	from django.http import HttpResponse
	def hello(request):
    	    return HttpResponse('<h1>Hello World-Blog!!!</h1>')
8) Подключаем наше второе приложение blog:
	--- в blogengine открываем файл settings.py
	--- в переменной INSTALLED_APPS дописываем в список 'blog'
	---- редактируем файл urls.py в blogengine:
	 аргументы path --- 2 позиционных - 'blog' - шаблон урла и метод, который должен выполняться при вызове этого шаблона. Еще 2 - это имя path и доп.данные в виде словаря, которые можно или нужно передать в метод.
	---- импортируем метод include: from django.urls import include
	---- переадресовываем через include на файд urls который в приложении blog --- path('blog/', include('blog.urls'))
 	---- создаем файл urls.py в blog - пишем в нем следующее: 
from django.urls import path
from .views import *

urlpatterns = [
    path('', post_list)
]
	---- переходим в файл views.py который в blog и создаем там метод post_list:
from django.shortcuts import render
from django.http import HttpResponse

def post_list(request):
    return HttpResponse('<h1>Hello WORLD~!!!</h1>')
----------------------------------------------------------------------------------------------------

9) Создаем в приложении blog папку templates, а в ней еще одну папку blog - для шаблонов html
10) Создадим файл index.html
11) Прописываем его на исполнение в view.py приложения blog:
def post_list(request):
    # return HttpResponse('<h1>Hello WORLD~!!!</h1>')
    return render(request, 'blog/index.html')

Все htmi-шаблоны django будет искать в папке templates




















































